# Volume

## 볼륨은 왜 필요한가?

- 일반적으로 도커에서 이미지는 읽기 전용으로 수정이 불가능하다.
- 컨테이너에서는 read write 권한을 주기 때문에 해당 위치에서는 수정이 가능하지만 원본의 이미지에는 아무 영향도 미치지 않는다.
- 그러나 컨테이너가 종료(삭제)가 된다면 수정했던 내용들은 저장되지 않고 사라지게 된다.
    - 즉, 컨테이너 layer에 존재하는 모든 데이터는 `**stateless**`로써, 컨테이너가 종료되면 사라지게 된다.
    - 쿠버네티스 파드 내에서 돌아가는 컨테이너는 고유한 파일 시스템을 갖음
        - 파일 시스템은 컨테이너 이미지에서 제공되기 때문
        - 즉, 컨테이너를 재시작하게 되면 이전에 쓰여진 변경 사항은 사라지고 기존의 이미지를 그대로 유지하기 때문에 변경사항이 적용된 컨테이너를 볼 수 없음

그렇다면 컨테이너가 종료되더라도 파일 시스템이 유지 되도록 할 수 있는 방법은 없을까?

- 컨테이너가 종료되어도 데이터를 유지할 수 있는 방법은 외부 디스크에 볼륨을 마운트 하는 것이다!
    - etc. 노드의 디스크, 클라우드 볼륨, git 등
    
    → 그렇다 해결책은 바로 `**볼륨**`이다!!
    

볼륨을 사용하게 되면 어떻게 될까? 예시를 들어 살펴보자!

일반적인 애플리케이션 컨테이너가 로그를 기록하고, 또다른 컨테이너는 로그를 읽어서 로그 서버로 전송하는 상황의 예시로 들어보자!

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled.png)

공유 스토리지를 사용하지 않을 경우, 모든 스토리지가 따로따로 지정되어 있는 상황이기 때문에 로그를 읽어서 서버로 전송을 할 수 없다. 이럴 때 볼륨을 공유함으로써 해당 기능을 수행할 수 있는 것을 확인할 수 있다!

쿠버네티스에서 지원하는 볼륨은 다양한 종류가 있는데, 지금부터 하나씩 알아보도록 해보자!

## 볼륨이란?

- 파드의 일부분으로 정의 되며 파드와 동일한 lifecyle을 갖는 디스크 스토리지
    - 볼륨은 pod 내에 존재하는 것을 알 수 있다.
        - → 파드의 구성요소로써 동일한 라이프사이클을 갖는 것!!
    - 즉, 볼륨은 독립적인 쿠버네티스의 리소스가 아니므로 자체적으로 삭제되거나 생성될 수 없다.
    - 이는 메모리가 아닌 디스크에 저장이 된다. 하지만 우리가 볼 수 없는 형태로써 저장되기 때문에 우리는 해당 파일을 볼 수 없다.
- 파드가 여러 개의 컨테이너를 가지고 있는 경우 모든 컨테이너가 볼륨을 공유할 수 있다.
    - 각 컨테이너들은 볼륨에 직접 마운트를 하여 접근할 수 있고, 컨테이너 파일 시스템 내부 어디에나 볼륨을 마운트 할 수 있다.

## 볼륨의 특징

- Pod에서 실제 데이터가 있는 디렉토리를 보존하기위해 사용
- pod의 일부로 정의되며, pod와 라이프사이클을 같이함
- 독립적인 쿠버네티니스 오브젝트가 아니며 스스로 생성하거나 삭제할 수 없다.
    - kind가 없다
- 마운트를 통해서만 사용할 수 있다
- 실제 호스트에서는 /var/lib/kubelet/pods/PODUID/volumes/ 위치에서 볼륨 확인 가능

## 볼륨의 종류

볼륨의 종류는 크게 일반 볼륨과 특수한 볼륨으로 나눌 수 있다.

> 참고로, 노드는 하나의 인스턴스(EC2)로 볼 수 있다.
> 
- `**일반 볼륨**`

| 종류 | 설명 |
| --- | --- |
| emptyDir | 일시적인 데이터를 저장하는데 사용. 비어있는 단순한 디렉토리 |
| hostPath | 노드의 파일 시스템에서 pod의 디렉토리로 마운트하는데 사용 |
| gitRepo | git 레포지토리를 checkout해서 초기화하는 볼륨 |
| nfs | pod에 마운트된 네트워크 파일 시스템 |
| gcePersistentDisk | 구글 클라우드 영구 디스크 |
| awsElastic-BlockStore | 아마존 클라우드 영구 디스크 |
| azureDisk | 애져 클라우드 영구 디스크 |
| 기타 | 다양한 스토리지 |

- `**특수한 볼륨**`

| 종류 | 설명 |
| --- | --- |
| configMap | 설정파일 및 환경 변수 보관하는 볼륨 |
| secret | 기밀 유지가 필요한 설정파일이나 환경 변수 보관하는 볼륨 |

지금부터 하나씩 제대로 살펴보자!

### EmptyDir

---

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%201.png)

- 일시적인 데이터를 저장하는 데 사용되는 간단한 빈 디렉터리
- EmptyDir은 pod가 종료되면 영구적으로 삭제됨
    - 파드와 동일한 라이프사이클을 가짐
    - 파드가 종료되면 디스크가 사라지는 형태

> 여기서 질문! pod가 종료되면 결국 삭제가 된다면 결국 컨테이너가 종료가 되어 삭제되는 것과 다르지 않다! 그럼 이걸 왜 사용하는걸까?
> 
- 무슨 용도?
    - 대규모 파일의 sorting 작업
        - 머신러닝이나 딥러닝 기술에서 수학 연산을 할 때, 해당 디스크에 중간 연산과정을 임시 저장하는데 사용된다
    - 파드 내의 컨테이너간 파일 교환
    - 복구를 위한 임시파일 보관

### hostPath

---

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%202.png)

- pod가 종료되어도 `**상태가 유지**` 된다.
- 노드의 파일 시스템의 특정 파일이나 디렉터리를 가르킨다.
    - 즉, 인스턴스 내부의 파일 시스템이나 디렉터리를 가르킨다는 의미로 볼 수 있다.
- 다만, 파드는 항상 **다른 노드로 이동 가능성이 존재**
    - 즉, 데이터베이스의 디렉터리로 사용하거나 여러 노드에 걸쳐 데이터를 유지하기 위해 사용하는 것은 적절하지 않다.
    
    ![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%203.png)
    
    ![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%204.png)
    
    ![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%205.png)
    
    - 위의 그림처럼 컨테이너가 죽고 다시 생성될때 node1이 아닌 node2에 생성이 된다고 가정하면, 해당 노드에 마운트된 볼륨이 아니기 때문에 저장된 내용을 볼 수 없게 된다.

그렇다면 다중 노드에서 퍼시스턴트 데이터를 저장하는 방법은 없을까?

그래서 쿠버네티스에서는 `**persistent volume(PV)**`이 존재한다!

# persistent volume(PV)

---

## persistent란?

- `**영속성(persistence)**`은 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성을 의미
- 파드에서 실행 중인 앱이 디스크에 데이터를 유지해야하고, 파드가 다른 노드로 스케줄링 된 경우에도 동일한 데이터를 사용하도록하기 위해서는 데이터가 어떤 클러스터 노드에서도 접근이 필요하다
    - 이런 경우, NAS 유형의 볼륨(EFS) 즉, GCE, AWS, MS Azure 등의 클라우드에서 제공하는 퍼시스턴트 스토리지를 사용할 수 있다.

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%206.png)

일반적으로 물리적 볼륨 위에 CSI(Container Storage Interface)가 동작하여 k8s와 물리적 볼륨(plugin) 사이의 인터페이스 역할을 해준다.

## AWS에서 제공하는 스토리지 알아보기

---

### EBS

- 포맷 여부 o
    - 파일 시스템으로 포맷되어 저렴하고 높은 성능을 제공
    - 단일 EC2 인스턴스에 연결되므로 인스턴스에 직접 연결되는 블록 수준의 스토리지로써 인스턴스에 특화된 스토리지 제공
    - 그러나 다수의 인스턴스에서 공유가 어렵기 때문에 스케일 아웃된 환경에서 사용하기 어려울 수 있다.
- RWO 지원 → 하나의 노드 안에서 여러 개의 pod가 실행중이라면 볼륨에 접근 가능
    - 즉, 속도와 rw 중시! → rw는 한명만 가능하다!!
- 볼륨기반 저장 서비스
    - HDD, SSD를 가상화 한 것으로 생각하면 된다.
- 다양한 AWS 서비스에 EFS를 마운트하고 다양한 가상머신에서 엑세스 가능
- s3나 EFS와 달리 독립형 스토리지가 아님(EC2와 함께 사용)
    - 인스턴스와 EBS의 네트워크 연결로 이루어짐
    - EBS와 인스턴스 연결이 끊어져도 EBS에 저장된 스토리지 사용 가능
    - EBS 한 개에 여러 인스턴스 연결 가능하며, 인스턴스 1개에 여러 EBS도 연결 가능하다
- EBS는 같은 가용영역(AZ)에 존재 → AZ가 같아야 연결 및 통신이 빠르기 때문이다.
- 데이터에 빠르게 액세스하고 장기적으로 지속해야하는 경우 적합
- 물리적 머신의 로컬 디스크 드라이브와 유사하게 EC2 인스턴스에 연결된, 프로비저닝 된 크기의 볼륨에 데이터를 저장하도록 설계 됨
- 단일 인스턴스에 대한 고성능 스토리지 서비스가 필요한 경우 유용
- NoSQL DB, ERP 시스템, 메일서버, 웹서버 또는 미들웨에어 적합하다
    - 큰 클러스터에서 실행되지 않는 워크로드로 마운트되는 볼륨이 필요 없다

### EFS

- 포맷 x
    - 포맷 없이 생성 시점에서 자동으로 파일 시스템이 생성됨
    - 다수의 인스턴스에 공유 가능하기 때문에 스케일 아웃 및 고가용성 지원
    - 파일 시스템을 직접 관리하지 않아도 되므로 자동화 및 간소화된 운영이 가능하다
    - 그러나 EBS보다 더 높은 비용이 든다.
    - 또한, 일부 시나리오에서 EBS보다 일부 느린 I/O 성능을 보일 수 있다.
- 파일 기반 저장 서비스(NFS, NAS와 동일하다고 보면 됨)
- 간단하고 확장 가능하며 탄력적인 완전 관리형 NFS 파일 시스템
    - 리전별 서비스인 EFS는 여러 가용영역(AZ)에 걸쳐 데이터를 중복으로 저장하여 높은 가용성과 내구성을 제공한다.
    
    → 즉, **다수의 인스턴스에서 파일에 접근할 수 있는 전송 지연 문제가 적다!**
    
- VPC 내 EC2 인스턴스는 직접 액세스 가능
- NFSv4(Network File System) 프로토콜 사용
- 2개 이상의 EC2로부터 공유된 스토리지 공간이 필요할 때 채택

### S3

- 객체 기반 저장 서비스
- 객체 기반 저장 서비스의 경우 rest API로 통신하며 업데이트 시 변경이 불가능 하다.
- 웹에서 사용 가능한 객체 저장소
- 고유 식별자(key)와 연결됨으로 어디서나 웹을 통해 엑세스 가능
- 저장 용량이 무한대이고 파일 저장에 최적화 되어있어 용량을 추가하거나 성능을 높이는 작업은 필요 없다

- 사례로 살펴보기
    - statfulset와 deployment
        - 디스크 3개 생성 / 디스크 1개 공유→ 마운트됨
        - 즉, 디플로이먼트로 rw가 한명만 가능하기 때문에 EBS로는 구성 불가, 즉 EFS로 해야함(여러 사람이 읽고 쓰기 가능) → 어플리케이션에 로그를 날린다고 가정했을 때

RWO? ROX? 이게 다 뭐지?

지금부터 살펴보도록 하자!

## volume access mode

---

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%207.png)

```
ReadWiteOnce(RWO)
- 하나의 노드에서 읽기/쓰기로 마운트
- 하나의 노드에서 여러개의 pod가 실행중이라면 볼륨에 접근이 가능

ReadOnlyMany(ROX)
- 여러노드에서 읽기 전용으로 마운트된 볼륨

ReadWriteMany(RWX)
- 여러노드에서 읽기/쓰기 전용으로 마운트된 볼륨

ReadWriteOncePod(RWOP)
- 하나의 파드에서 읽기/쓰기로 마운트된 볼륨
```

# 볼륨의 생성

이제부터 볼륨을 생성해보자!

볼륨을 생성하는 방법에 있어서는 직접 생성과 간접 생성이 존재한다.

## 볼륨 직접 생성과 간접 생성의 차이

---

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%208.png)

- 직접 생성
    - 직접 생성의 경우, yaml 파일에 GCE에서 생성한 Disk의 정보를 알고 직접 입력해야만 마운트가 가능하다
- 간접 생성
    - 쿠버네티스와 어울리는 기능들을 넣기 위해서
        - 즉, 정책을 넣을 수 있음
        - 아무리 파드가 삭제 되더라도 유지가 되게 할것인가?
    - 같은 네임스페이스 안에서는 같은 claim을 가지고 정책 사용가능
        - persistent volume의 경우는 네임스페이스 밖에 위치하고 있음
    - pvc를 삭제했다고 pv가 삭제되는 것이 아님

**즉, 개발자가 디스크나 인프라에 대해 자세히 알지 못해도 pvc를 이용하여 손쉽게 디스크를 사용하고 해지할  수 있다.**

## PV와 PVC

---

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%209.png)

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%2010.png)

- 사용자는 pvc와 pod만 생성
- persistence 프로비즈너의 경우, PV 생성과 default 스토리지 클래스를 생성

## PV와 PVC의 수명 정리

---

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%2011.png)

# 정적 프로비저닝과 동적 프로비저닝

## 쿠버네티스에서 볼륨을 사용하는 방법

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%2012.png)

# 실습 총정리

![Untitled](Volume%20c6254ffd616842a3829ec28bda454744/Untitled%2013.png)

# 정리

---

- Ingress
- ConfigMap, secret
    - 컨테이너의 설정파일(소스코드를 제외한 나머지)를 변경할 때 사용
- volume
    - pod → DB
    - pod → pvc → pv → DB
        - 개발자와 운영자를 나누기 위해서 고안된 것
        - 그러나 aws에서는 지원이 안됨(구글은 가능)
    - pod → sc → aws
        - 실제로 가장 많이 사용
        - 동적임(위의 두개는 정적)

- 찾아볼 것
    - eventually
    - consistency
        - 릴레이션 데이터베이스에서 해방되기 위한 방안이 나옴
        - mongodb…

- 결국 일관성이 중요
    - 한국에 있는 글이 실시간으로 미국의 리전에 있는 트위터 디비에도 가야함
    - 즉, 동시성 문제가 발생하게 됨
        - 내가 글을 올린 사이 미국에는 내가 올린 게시글에 대한 내용을 보고 있지 못할 수도 있음
        - 이러한 문제를 위의 eventually, consistency가 나타나면서 결국 일관성을 맞춰주게되었다?
        - 멀티존에서 디비 클러스터를 올렸을 때 어떻게 해결해야할까?를 고민해보기!